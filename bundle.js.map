{"version":3,"sources":["node_modules/browser-pack/_prelude.js","lib/runExclusive.js","node_modules/minimal-polyfills/Map.js","node_modules/minimal-polyfills/WeakMap.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA","file":"generated.js","sourceRoot":"","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\"use strict\";\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nexports.__esModule = true;\nexports.buildMethodCb = exports.buildCb = exports.getPrComplete = exports.isRunning = exports.cancelAllQueuedCalls = exports.getQueuedCallCount = exports.buildMethod = exports.build = exports.createGroupRef = void 0;\nvar WeakMap_1 = require(\"minimal-polyfills/WeakMap\");\nvar ExecQueue = /** @class */ (function () {\n    function ExecQueue() {\n        this.queuedCalls = [];\n        this.isRunning = false;\n        this.prComplete = Promise.resolve();\n    }\n    //TODO: move where it is used.\n    ExecQueue.prototype.cancelAllQueuedCalls = function () {\n        var n;\n        this.queuedCalls.splice(0, n = this.queuedCalls.length);\n        return n;\n    };\n    return ExecQueue;\n}());\nvar globalContext = {};\nvar clusters = new WeakMap_1.Polyfill();\n//console.log(\"Map version\");\n//export const clusters = new Map<Object, Map<GroupRef,ExecQueue>>();\nfunction getOrCreateExecQueue(context, groupRef) {\n    var execQueueByGroup = clusters.get(context);\n    if (!execQueueByGroup) {\n        execQueueByGroup = new WeakMap_1.Polyfill();\n        clusters.set(context, execQueueByGroup);\n    }\n    var execQueue = execQueueByGroup.get(groupRef);\n    if (!execQueue) {\n        execQueue = new ExecQueue();\n        execQueueByGroup.set(groupRef, execQueue);\n    }\n    return execQueue;\n}\nfunction createGroupRef() {\n    return new Array(0);\n}\nexports.createGroupRef = createGroupRef;\nfunction build() {\n    var inputs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        inputs[_i] = arguments[_i];\n    }\n    switch (inputs.length) {\n        case 1: return buildFnPromise(true, createGroupRef(), inputs[0]);\n        case 2: return buildFnPromise(true, inputs[0], inputs[1]);\n    }\n}\nexports.build = build;\nfunction buildMethod() {\n    var inputs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        inputs[_i] = arguments[_i];\n    }\n    switch (inputs.length) {\n        case 1: return buildFnPromise(false, createGroupRef(), inputs[0]);\n        case 2: return buildFnPromise(false, inputs[0], inputs[1]);\n    }\n}\nexports.buildMethod = buildMethod;\n/**\n *\n * Get the number of queued call of a run-exclusive function.\n * Note that if you call a runExclusive function and call this\n * directly after it will return 0 as there is one function call\n * execution ongoing but 0 queued.\n *\n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n *\n * */\nfunction getQueuedCallCount(runExclusiveFunction, classInstanceObject) {\n    var execQueue = getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n    return execQueue ? execQueue.queuedCalls.length : 0;\n}\nexports.getQueuedCallCount = getQueuedCallCount;\n/**\n *\n * Cancel all queued calls of a run-exclusive function.\n * Note that the current running call will not be cancelled.\n *\n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n *\n */\nfunction cancelAllQueuedCalls(runExclusiveFunction, classInstanceObject) {\n    var execQueue = getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n    return execQueue ? execQueue.cancelAllQueuedCalls() : 0;\n}\nexports.cancelAllQueuedCalls = cancelAllQueuedCalls;\n/**\n * Tell if a run-exclusive function has an instance of it's call currently being\n * performed.\n *\n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n */\nfunction isRunning(runExclusiveFunction, classInstanceObject) {\n    var execQueue = getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n    return execQueue ? execQueue.isRunning : false;\n}\nexports.isRunning = isRunning;\n/**\n * Return a promise that resolve when all the current queued call of a runExclusive functions\n * have completed.\n *\n * The classInstanceObject parameter is to provide only for the run-exclusive\n * function created with 'buildMethod[Cb].\n */\nfunction getPrComplete(runExclusiveFunction, classInstanceObject) {\n    var execQueue = getExecQueueByFunctionAndContext(runExclusiveFunction, classInstanceObject);\n    return execQueue ? execQueue.prComplete : Promise.resolve();\n}\nexports.getPrComplete = getPrComplete;\nvar groupByRunExclusiveFunction = new WeakMap_1.Polyfill();\nfunction getExecQueueByFunctionAndContext(runExclusiveFunction, context) {\n    if (context === void 0) { context = globalContext; }\n    var groupRef = groupByRunExclusiveFunction.get(runExclusiveFunction);\n    if (!groupRef) {\n        throw Error(\"Not a run exclusiveFunction\");\n    }\n    var execQueueByGroup = clusters.get(context);\n    if (!execQueueByGroup) {\n        return undefined;\n    }\n    return execQueueByGroup.get(groupRef);\n}\nfunction buildFnPromise(isGlobal, groupRef, fun) {\n    var execQueue;\n    var runExclusiveFunction = (function () {\n        var _this = this;\n        var inputs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            inputs[_i] = arguments[_i];\n        }\n        if (!isGlobal) {\n            if (!(this instanceof Object)) {\n                throw new Error(\"Run exclusive, <this> should be an object\");\n            }\n            execQueue = getOrCreateExecQueue(this, groupRef);\n        }\n        return new Promise(function (resolve, reject) {\n            var onPrCompleteResolve;\n            execQueue.prComplete = new Promise(function (resolve) {\n                return onPrCompleteResolve = function () { return resolve(); };\n            });\n            var onComplete = function (result) {\n                onPrCompleteResolve();\n                execQueue.isRunning = false;\n                if (execQueue.queuedCalls.length) {\n                    execQueue.queuedCalls.shift()();\n                }\n                if (\"data\" in result) {\n                    resolve(result.data);\n                }\n                else {\n                    reject(result.reason);\n                }\n            };\n            (function callee() {\n                var _this = this;\n                var inputs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    inputs[_i] = arguments[_i];\n                }\n                if (execQueue.isRunning) {\n                    execQueue.queuedCalls.push(function () { return callee.apply(_this, inputs); });\n                    return;\n                }\n                execQueue.isRunning = true;\n                try {\n                    fun.apply(this, inputs)\n                        .then(function (data) { return onComplete({ data: data }); })[\"catch\"](function (reason) { return onComplete({ reason: reason }); });\n                }\n                catch (error) {\n                    onComplete({ \"reason\": error });\n                }\n            }).apply(_this, inputs);\n        });\n    });\n    if (isGlobal) {\n        execQueue = getOrCreateExecQueue(globalContext, groupRef);\n    }\n    groupByRunExclusiveFunction.set(runExclusiveFunction, groupRef);\n    return runExclusiveFunction;\n}\nfunction buildCb() {\n    var inputs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        inputs[_i] = arguments[_i];\n    }\n    switch (inputs.length) {\n        case 1: return buildFnCallback(true, createGroupRef(), inputs[0]);\n        case 2: return buildFnCallback(true, inputs[0], inputs[1]);\n    }\n}\nexports.buildCb = buildCb;\nfunction buildMethodCb() {\n    var inputs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        inputs[_i] = arguments[_i];\n    }\n    switch (inputs.length) {\n        case 1: return buildFnCallback(false, createGroupRef(), inputs[0]);\n        case 2: return buildFnCallback(false, inputs[0], inputs[1]);\n    }\n}\nexports.buildMethodCb = buildMethodCb;\nfunction buildFnCallback(isGlobal, groupRef, fun) {\n    var execQueue;\n    var runExclusiveFunction = (function () {\n        var _this = this;\n        var inputs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            inputs[_i] = arguments[_i];\n        }\n        if (!isGlobal) {\n            if (!(this instanceof Object)) {\n                throw new Error(\"Run exclusive, <this> should be an object\");\n            }\n            execQueue = getOrCreateExecQueue(this, groupRef);\n        }\n        var callback = undefined;\n        if (inputs.length && typeof inputs[inputs.length - 1] === \"function\") {\n            callback = inputs.pop();\n        }\n        var onPrCompleteResolve;\n        execQueue.prComplete = new Promise(function (resolve) {\n            return onPrCompleteResolve = function () { return resolve(); };\n        });\n        var onComplete = function () {\n            var inputs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                inputs[_i] = arguments[_i];\n            }\n            onPrCompleteResolve();\n            execQueue.isRunning = false;\n            if (execQueue.queuedCalls.length) {\n                execQueue.queuedCalls.shift()();\n            }\n            if (callback) {\n                callback.apply(_this, inputs);\n            }\n        };\n        onComplete.hasCallback = !!callback;\n        (function callee() {\n            var _this = this;\n            var inputs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                inputs[_i] = arguments[_i];\n            }\n            if (execQueue.isRunning) {\n                execQueue.queuedCalls.push(function () { return callee.apply(_this, inputs); });\n                return;\n            }\n            execQueue.isRunning = true;\n            try {\n                fun.apply(this, __spreadArrays(inputs, [onComplete]));\n            }\n            catch (error) {\n                error.message += \" ( This exception should not have been thrown, miss use of run-exclusive buildCb )\";\n                throw error;\n            }\n        }).apply(this, inputs);\n    });\n    if (isGlobal) {\n        execQueue = getOrCreateExecQueue(globalContext, groupRef);\n    }\n    groupByRunExclusiveFunction.set(runExclusiveFunction, groupRef);\n    return runExclusiveFunction;\n}\n//# sourceMappingURL=runExclusive.js.map","\"use strict\";\nexports.__esModule = true;\nexports.Polyfill = exports.LightMapImpl = void 0;\nvar LightMapImpl = /** @class */ (function () {\n    function LightMapImpl() {\n        this.record = [];\n    }\n    LightMapImpl.prototype.has = function (key) {\n        return this.record\n            .map(function (_a) {\n            var _key = _a[0];\n            return _key;\n        })\n            .indexOf(key) >= 0;\n    };\n    LightMapImpl.prototype.get = function (key) {\n        var entry = this.record\n            .filter(function (_a) {\n            var _key = _a[0];\n            return _key === key;\n        })[0];\n        if (entry === undefined) {\n            return undefined;\n        }\n        return entry[1];\n    };\n    LightMapImpl.prototype.set = function (key, value) {\n        var entry = this.record\n            .filter(function (_a) {\n            var _key = _a[0];\n            return _key === key;\n        })[0];\n        if (entry === undefined) {\n            this.record.push([key, value]);\n        }\n        else {\n            entry[1] = value;\n        }\n        return this;\n    };\n    LightMapImpl.prototype[\"delete\"] = function (key) {\n        var index = this.record.map(function (_a) {\n            var key = _a[0];\n            return key;\n        }).indexOf(key);\n        if (index < 0) {\n            return false;\n        }\n        this.record.splice(index, 1);\n        return true;\n    };\n    LightMapImpl.prototype.keys = function () {\n        return this.record.map(function (_a) {\n            var key = _a[0];\n            return key;\n        });\n    };\n    return LightMapImpl;\n}());\nexports.LightMapImpl = LightMapImpl;\nexports.Polyfill = typeof Map !== \"undefined\" ? Map : LightMapImpl;\n//# sourceMappingURL=Map.js.map","\"use strict\";\nexports.__esModule = true;\nexports.Polyfill = void 0;\nvar Map_1 = require(\"./Map\");\nexports.Polyfill = typeof WeakMap !== \"undefined\" ? WeakMap : Map_1.Polyfill;\n//# sourceMappingURL=WeakMap.js.map"]}